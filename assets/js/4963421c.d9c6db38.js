"use strict";(self.webpackChunkwarp_docs=self.webpackChunkwarp_docs||[]).push([[487],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>y});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=d(n),y=i,f=u["".concat(c,".").concat(y)]||u[y]||p[y]||a;return n?r.createElement(f,o(o({ref:t},l),{},{components:n})):r.createElement(f,o({ref:t},l))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<a;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8184:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(7462),i=(n(7294),n(3905));const a={title:"ABI Encode"},o=void 0,s={unversionedId:"solidity_equivalents/abi_encode",id:"solidity_equivalents/abi_encode",title:"ABI Encode",description:"When transpiling solidity code which uses ABI encoding, cairo functions are generated to mimic this behaviour.",source:"@site/docs/solidity_equivalents/abi_encode.mdx",sourceDirName:"solidity_equivalents",slug:"/solidity_equivalents/abi_encode",permalink:"/warp/docs/solidity_equivalents/abi_encode",editUrl:"https://github.com/NethermindEth/warp/tree/develop/docs/docs/solidity_equivalents/abi_encode.mdx",tags:[],version:"current",frontMatter:{title:"ABI Encode"},sidebar:"tutorialSidebar",previous:{title:"Solidity Equivalents",permalink:"/warp/docs/category/solidity-equivalents"},next:{title:"Addresses",permalink:"/warp/docs/solidity_equivalents/addresses"}},c=[],d={toc:c};function l(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When transpiling solidity code which uses ABI encoding, cairo functions are generated to mimic this behaviour.\nThese functions return a felt array where each element is between 0 and 255, a representation of Solidity's bytes array."),(0,i.kt)("p",null,"ABI Encoding and Packed Encoding on both solidity and warped contracts will be similar except for addresses.\nDue to cairo addresses being able to occupy the whole felt space and solidity's being only 160 bits (considerably smaller) it creates compatibility issues, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When ABI Encoding:\nalthough each data type occupies 32 bytes slot, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"felt")," fits perfectly inside,\nan address encoded on a warped contract on Starknet and later decoded on a L1 will\ncause a ",(0,i.kt)("inlineCode",{parentName:"p"},"revert")," if the address is bigger than 20 bytes. If you wish to decode a cairo address on L1 you must\nsubstitute the address type for ",(0,i.kt)("inlineCode",{parentName:"p"},"uint256")," (or other similar size type) e.g ",(0,i.kt)("inlineCode",{parentName:"p"},"abi.decode(data, (address))")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"abi.decode(data, (uint256))"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When ABI Packed Encoding: instead of storing the cairo address inside 20 bytes and having a potential\ninformation lost, they are stored as 32 bytes. As a consequence, the packed encoding in a warped contract\nand the solidity contract will always differ if addresses are one of the included types."))))}l.isMDXComponent=!0}}]);