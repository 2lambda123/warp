"use strict";(self.webpackChunkwarp_docs=self.webpackChunkwarp_docs||[]).push([[330],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>f});var n=r(7294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var d=n.createContext({}),l=function(e){var t=n.useContext(d),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=l(e.components);return n.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,s=e.mdxType,o=e.originalType,d=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),u=l(r),f=s,m=u["".concat(d,".").concat(f)]||u[f]||p[f]||o;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function f(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=r.length,i=new Array(o);i[0]=u;var a={};for(var d in t)hasOwnProperty.call(t,d)&&(a[d]=t[d]);a.originalType=e,a.mdxType="string"==typeof e?e:s,i[1]=a;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},1629:(e,t,r)=>{r.r(t),r.d(t,{contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var n=r(7462),s=(r(7294),r(3905));const o={title:"Addresses"},i=void 0,a={unversionedId:"solidity_equivalents/addresses",id:"solidity_equivalents/addresses",title:"Addresses",description:"An Ethereum address has a width of 160 bits, while a StarkNet address has a width of 251 bits. To support this change in address size, we had to modified the solc compiler. As a result, Warp's flavour of Solidity uses 256 bits for addresses instead of 160.",source:"@site/docs/solidity_equivalents/addresses.mdx",sourceDirName:"solidity_equivalents",slug:"/solidity_equivalents/addresses",permalink:"/warp/docs/solidity_equivalents/addresses",editUrl:"https://github.com/NethermindEth/warp/tree/develop/docs/docs/solidity_equivalents/addresses.mdx",tags:[],version:"current",frontMatter:{title:"Addresses"},sidebar:"tutorialSidebar",previous:{title:"ABI Encode",permalink:"/warp/docs/solidity_equivalents/abi_encode"},next:{title:"Transcoding Inputs for Starknet Contracts",permalink:"/warp/docs/solidity_equivalents/inputs"}},d=[],l={toc:d};function c(e){let{components:t,...r}=e;return(0,s.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Ethereum address has a width of 160 bits, while a StarkNet address has a width of 251 bits. To support this change in address size, we had to modified the solc compiler. As a result, Warp's flavour of Solidity uses 256 bits for addresses instead of 160."),(0,s.kt)("p",null,"This modification means there are some things to consider when using the address type in Warp."),(0,s.kt)("p",null,"First, the bounds of an address are not checked at compile time, which can introduce strange behaviour.\nThe expression ",(0,s.kt)("inlineCode",{parentName:"p"},"address(uint256(MAX_UINT256))")," will not cause any compile time or runtime errors even though the maximum value for addresses is ",(0,s.kt)("inlineCode",{parentName:"p"},"2**251 - 1"),"."),(0,s.kt)("p",null,"Second, the ",(0,s.kt)("inlineCode",{parentName:"p"},"ecrecover")," precompile now returns uint160 and not an address type. The",(0,s.kt)("inlineCode",{parentName:"p"},"ecrecover")," function does not work with StarkNet's curve, using it to try return a StarkNet address will cause errors. The function will only work when recovering an Ethereum address and returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"uint160")," type and not an ",(0,s.kt)("inlineCode",{parentName:"p"},"address")," type."))}c.isMDXComponent=!0}}]);